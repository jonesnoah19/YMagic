# -*- coding: utf-8 -*-
"""
YMagic

A tool for analyzing a Magic the Gathering decklist.

You can use saved decks from Magic Arena, Magic the Gathering Online, and
text-based deck lists.

@author: Noah Jones
"""
import time
import re
import json
import xml.etree.ElementTree as ET
import requests
import matplotlib.pyplot as plt

def searchExactName(text):
    '''
    Search using Scryfall api for card name, "exact" parameters are used.

    Args:
        text: a card's exact name
    '''
    print(f"\n Fetching results for '{text}': \n")
    if not isinstance(text, str):               #Typechecking the text variable
        print("Please enter a card name as a string: \n")
    else:
        para = {"exact":text}
        response = requests.get("https://api.scryfall.com/cards/named", params=para)
        time.sleep(0.11)                        #Scryfall api asks for 50-100ms delay
        print("Done.")
        if response.status_code != 200:
            print(f'Request issue: Status Code {response.status_code}')
            if response.status_code == 429:
                print('Too many requests error.')
                response.raise_for_status()     #Raise error if sending too many requests
    return response


def getCards(decky):
    '''
    Calls api search on each name in a decky and stores each cards' JSON

    Args:
        decky: A list of lists generated by our parsing functions.
    '''
    for card in decky[1]:
        if not card.isspace():
            resp = searchExactName(card)
            decky[3].append(resp.json())
            decky[4].append(resp.status_code)
    return


def parseWrapper(decklist=None):
    '''
    Checks file type and decides which parse function to use.

    Parameters
    ----------
    decklist : string, optional
        File path to a deck list. If None is provided, the user will be prompted for one.

    Returns
    -------
    list
        Returns the result of one of the parse functions. A decky with quantity and card name.
    '''
    #
    if decklist is None:
        decklist = input('Please enter a filepath to a decklist: ')     #'./Decks/phoenix.txt'
    if decklist.endswith('.txt'):
        return parseTXT(decklist)
    if decklist.endswith(('.xml', '.dek')):
        return parseXML(decklist)
    else:
        print('Unexpected file type. Currently supports .txt, .xml, .dek')
        return None


def parseTXT(decklist):
    decky = [[], [], [], [], []]            #Quantity, Card name, Sideboard, Json, Status
    reg = re.compile(                   #Compile a regex from the string
        r'''
         (\d+\s)                    #Quantity followed by space
         ([a-zA-Z-,' /]+)           #Card name, alphabet and -,' /
         ''', re.VERBOSE | re.IGNORECASE)
    with open(decklist, 'r') as file:               #open file in read mode
        lines = file.read().split("\n")
    for line in lines:
        match = reg.search(line)
        if match is not None:
            #print(match.groups()) #is a list of regex group matches
            qtyStr = match.groups()[0]          #Regex match for quantity
            qty = int(qtyStr.rstrip())
            decky[0].append(qty)
            nameStr = match.groups()[1].rstrip()        #Regex match for name
            decky[1].append(nameStr)
    return decky


def parseXML(decklist):
    decky = [[], [], [], [], []]          #Quantity, Card name, Sideboard, Json, Status
    tree = ET.parse(decklist)           #XML file to tree
    root = tree.getroot()
    for card in root.findall('Cards'):
        qty = int(card.get('Quantity'))
        decky[0].append(qty)
        name = card.get('Name')
        decky[1].append(name)
        side = card.get('Sideboard')
        decky[2].append(side)
    return decky


def stats(decky):
    '''
    Calculates and plots important metrics for the decky.

    Returns
    -------
    None.
    '''
    cmcs = dict.fromkeys(range(0, 17), 0)   # a dict with a key for each cmc
    #Inclusive counts a White/Blue card as both white and blue
    colors_inclusive = dict.fromkeys(list('WUBRGC'), 0)
    #Exclusive counts a White/Blue card as only multicolor
    colors_exclusive = dict.fromkeys(list('WUBRGCM'), 0)

    #Loop through cards to identify nonland and count their manacost
    i = 0
    for i in range(len(decky[3])):
        sup, sub = typeline(decky[3][i].get('type_line'))

        if 'Land' in sup:
            #Dryad Arbor is a well-known edge case
            #A green, 0-cmc Land Creature
            if decky[3][i].get('name') == 'Dryad Arbor':
                qty = decky[0][i]
                cmcs[0] = cmcs[0] + qty
                colors_inclusive['G'] = colors_inclusive['G'] + qty
                colors_exclusive['G'] = colors_exclusive['G'] + qty

        else:
            qty = decky[0][i]

            #Count manacosts
            value = decky[3][i].get('cmc')
            cmcs[value] = cmcs[value] + qty

            #Check for dual-faced cards
            if decky[3][i].get('card_faces') is not None:
                continue

            #Count cards by color both inclusive and exclusive
            cols = decky[3][i].get('colors')
            if cols == []:        #API returns [] for colorless
                colors_inclusive['C'] = colors_inclusive['C'] + qty
                colors_exclusive['C'] = colors_exclusive['C'] + qty
            if len(cols) > 1:     #List is only >1 for multicolor/hybrid costs
                colors_exclusive['M'] = colors_exclusive['M'] + qty
            for c in cols:
                colors_inclusive[c] = colors_inclusive[c] + qty
                if len(cols) == 1:
                    colors_exclusive[c] = colors_exclusive[c] + qty

    #Call ploting functions
    plotCMCs(cmcs)
    plotColors(colors_inclusive)
    #Graphs are identical for deck with no multicolored cards
    if colors_exclusive['M'] > 0:
        plotColors(colors_exclusive)
    return


def plotCMCs(cmcdict):
    #Remove unused high-cost keys
    cmcdict = {key: value for key, value in cmcdict.items() if value}
    for i in range(0, max(cmcdict)):
        cmcdict.setdefault(i, 0)

    #Bar Plot
    fig, ax = plt.subplots()
    ax.bar(x=list(cmcdict.keys()),
           height=list(cmcdict.values()),
           tick_label=list(cmcdict.keys())
           )
    ax.set_ylabel('Quantity')
    ax.set_xlabel('Mana Cost')
    ax.set_title('Mana Curve')
    return


def plotColors(colordict):
    #Remove unused colors
    colordict = {key: value for key, value in colordict.items() if value}
    #Build a list for displayed labels
    labels = []
    for key in colordict.keys():
        if key == 'W': labels.append('White')
        if key == 'U': labels.append('Blue')
        if key == 'B': labels.append('Black')
        if key == 'R': labels.append('Red')
        if key == 'G': labels.append('Green')
        if key == 'C': labels.append('Colorless')
        if key == 'M': labels.append('Multicolor')
    #Build a list for displayed colors
    colors = []
    for key in colordict.keys():
        if key == 'W': colors.append('#FFFFCC')
        if key == 'U': colors.append('#0033CC')
        if key == 'B': colors.append('#3E003E')
        if key == 'R': colors.append('#CC0000')
        if key == 'G': colors.append('#008000')
        if key == 'C': colors.append('#B2B2B2')
        if key == 'M': colors.append('#ffd700')

    #Pie Plot
    fig, ax = plt.subplots()
    ax.pie(x=list(colordict.values()),
           labels=labels,
           colors=colors,
           autopct='%1.1f%%',
           wedgeprops={'edgecolor':'black'},
           textprops={'color':'black', 'fontsize':'12'}
           )
    #Set Title
    if 'Multicolor' in labels:
        ax.set_title('Color Count (Exclusive)')
    else:
        ax.set_title('Color Count (Inclusive)')
    return


def typeline(line):
    '''
    Parses type line according to API standards, back face info is
    partitioned but not fully supported.

    Parameters
    ----------
    line : str
        The string to parse from a card's typeline

    Returns
    -------
    sup : str
        Supertype of card: ie: Land/Creature/Plane. Also includes Legendary.
    sub : str
        Subtype of card ie: Zombie/Island/Saga/Liliana.
    '''
    if not isinstance(line, str):
        raise TypeError("Expected string to parse.")    #Error handling in case of nonstring
    (front, _, back) = line.partition('//')
    (suptype, _, subtype) = front.partition('\u2014') #unicode em dash
    sup = suptype.strip().split(' ')
    sub = subtype.strip().split(' ')
    return (sup, sub)

def jprint(js):
    '''
    Pretty print JSON objects as string, for testing

    Args:
            js: JSON string, such as the .json() method of Scryfall api response
    '''
    text = json.dumps(js, sort_keys=False, indent=4)
    print(text)
    return

def main():
    DECKY = parseWrapper()
    getCards(DECKY)
    stats(DECKY)

if __name__ == '__main__':
    main()
